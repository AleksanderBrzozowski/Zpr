<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Zpr: CrossFactory Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Zpr
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classCrossFactory-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CrossFactory Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Factory creating crosses from given roads.  
 <a href="classCrossFactory.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a20b57828696dfc9e8a2f3384d5d29bae"><td class="memItemLeft" align="right" valign="top">PtrCross&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCrossFactory.html#a20b57828696dfc9e8a2f3384d5d29bae">findCrossByPoint</a> (const PtrToConstPoint &amp;) const </td></tr>
<tr class="memdesc:a20b57828696dfc9e8a2f3384d5d29bae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the cross that has the same position as the given point as the argument.  <a href="#a20b57828696dfc9e8a2f3384d5d29bae">More...</a><br/></td></tr>
<tr class="separator:a20b57828696dfc9e8a2f3384d5d29bae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accdbbd63f5a76a62269e1dde580b72b7"><td class="memItemLeft" align="right" valign="top">PtrCross&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCrossFactory.html#accdbbd63f5a76a62269e1dde580b72b7">createNewCross</a> (const PtrToConstPoint &amp;)</td></tr>
<tr class="memdesc:accdbbd63f5a76a62269e1dde580b72b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creating new cross if it doesn't exist.  <a href="#accdbbd63f5a76a62269e1dde580b72b7">More...</a><br/></td></tr>
<tr class="separator:accdbbd63f5a76a62269e1dde580b72b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee15c59ec2656c5cc422a889c30d4581"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCrossFactory.html#aee15c59ec2656c5cc422a889c30d4581">createRoad</a> (const PtrToConstPoint &amp;, const PtrToConstPoint &amp;)</td></tr>
<tr class="memdesc:aee15c59ec2656c5cc422a889c30d4581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updating crosses, creating new crosses from the given road.  <a href="#aee15c59ec2656c5cc422a889c30d4581">More...</a><br/></td></tr>
<tr class="separator:aee15c59ec2656c5cc422a889c30d4581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ac0c74d33e41161119e56e9995243e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCrossFactory.html#ae8ac0c74d33e41161119e56e9995243e">vertCrossedRoad</a> (const PtrToConstPoint &amp;, const PtrToConstPoint &amp;)</td></tr>
<tr class="memdesc:ae8ac0c74d33e41161119e56e9995243e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates crosses if new road crosses the existed one verticaly.  <a href="#ae8ac0c74d33e41161119e56e9995243e">More...</a><br/></td></tr>
<tr class="separator:ae8ac0c74d33e41161119e56e9995243e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ea5359b31f09f76510c90e9b4552e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCrossFactory.html#ae1ea5359b31f09f76510c90e9b4552e5">horizCrossedRoad</a> (const PtrToConstPoint &amp;, const PtrToConstPoint &amp;)</td></tr>
<tr class="memdesc:ae1ea5359b31f09f76510c90e9b4552e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates crosses if new road crosses the existed one horizontaly.  <a href="#ae1ea5359b31f09f76510c90e9b4552e5">More...</a><br/></td></tr>
<tr class="separator:ae1ea5359b31f09f76510c90e9b4552e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabc61b3a89fc71f7758780135c599e97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCrossFactory.html#aabc61b3a89fc71f7758780135c599e97">twoHorizRoads</a> (const PtrToConstPoint &amp;, const PtrToConstPoint &amp;)</td></tr>
<tr class="memdesc:aabc61b3a89fc71f7758780135c599e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates crosses if new road hide the existing, both roads are horizontaly.  <a href="#aabc61b3a89fc71f7758780135c599e97">More...</a><br/></td></tr>
<tr class="separator:aabc61b3a89fc71f7758780135c599e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac699978962ee263fb01c189891cb4a9b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCrossFactory.html#ac699978962ee263fb01c189891cb4a9b">twoVertRoads</a> (const PtrToConstPoint &amp;, const PtrToConstPoint &amp;)</td></tr>
<tr class="memdesc:ac699978962ee263fb01c189891cb4a9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates crosses if new road hide the existing, both roads are verticaly.  <a href="#ac699978962ee263fb01c189891cb4a9b">More...</a><br/></td></tr>
<tr class="separator:ac699978962ee263fb01c189891cb4a9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae413173adae2b63cb79c6ac13aaa99d5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae413173adae2b63cb79c6ac13aaa99d5"></a>
std::vector&lt; PtrCross &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getCrosses</b> ()</td></tr>
<tr class="separator:ae413173adae2b63cb79c6ac13aaa99d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a38f0b619437d1d866da32739aecb85eb"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCrossFactory.html#a38f0b619437d1d866da32739aecb85eb">cmpCrossX</a> (const PtrCross &amp;, const PtrCross &amp;)</td></tr>
<tr class="memdesc:a38f0b619437d1d866da32739aecb85eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">X value of cross position comparator for sorting.  <a href="#a38f0b619437d1d866da32739aecb85eb">More...</a><br/></td></tr>
<tr class="separator:a38f0b619437d1d866da32739aecb85eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3f69512a614ed1f57c7595bd21f10c1"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCrossFactory.html#ac3f69512a614ed1f57c7595bd21f10c1">cmpCrossY</a> (const PtrCross &amp;, const PtrCross &amp;)</td></tr>
<tr class="memdesc:ac3f69512a614ed1f57c7595bd21f10c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Y value of cross position comparator for sorting.  <a href="#ac3f69512a614ed1f57c7595bd21f10c1">More...</a><br/></td></tr>
<tr class="separator:ac3f69512a614ed1f57c7595bd21f10c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Factory creating crosses from given roads. </p>
<p>Factory is able to create new crosses and update their neighbours. If new road crosses the road that already exists, new crosses at the crosses are created and neighbours are updated. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a38f0b619437d1d866da32739aecb85eb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CrossFactory::cmpCrossX </td>
          <td>(</td>
          <td class="paramtype">const PtrCross &amp;&#160;</td>
          <td class="paramname"><em>cr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PtrCross &amp;&#160;</td>
          <td class="paramname"><em>cr2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>X value of cross position comparator for sorting. </p>
<p>Returns true if cross1 is nearer left. If both crosses have the same x, returns true if cross1 has smaller y than cross2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cr1</td><td>- first cross. </td></tr>
    <tr><td class="paramname">cr2</td><td>- second cross. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if x value of cross 1 is smaller than x value of cross 2, if both x values are the same, returns true if y value of cross 1 is smaller. </dd></dl>

</div>
</div>
<a class="anchor" id="ac3f69512a614ed1f57c7595bd21f10c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CrossFactory::cmpCrossY </td>
          <td>(</td>
          <td class="paramtype">const PtrCross &amp;&#160;</td>
          <td class="paramname"><em>cr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PtrCross &amp;&#160;</td>
          <td class="paramname"><em>cr2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Y value of cross position comparator for sorting. </p>
<p>Returns true if cross1 is nearer top. If both crosses have the same y, returns true if cross1 has smaller x than cross2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cr1</td><td>- first cross. </td></tr>
    <tr><td class="paramname">cr2</td><td>- second cross. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if y value of cross1 is smaller than y value of cross2, if both y values are the same, returns true if x value of cross1 is smaller. </dd></dl>

</div>
</div>
<a class="anchor" id="accdbbd63f5a76a62269e1dde580b72b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PtrCross CrossFactory::createNewCross </td>
          <td>(</td>
          <td class="paramtype">const PtrToConstPoint &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creating new cross if it doesn't exist. </p>
<p>Checking if cross at given position already exists. If not creates new cross. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>- point at which we want to create new cross. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cross at given point. </dd></dl>

</div>
</div>
<a class="anchor" id="aee15c59ec2656c5cc422a889c30d4581"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CrossFactory::createRoad </td>
          <td>(</td>
          <td class="paramtype">const PtrToConstPoint &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PtrToConstPoint &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updating crosses, creating new crosses from the given road. </p>
<p>Reverses the begin and ending point of the road if the ending point is nearer top left corner of the map. Then calls methods if the new road is horizontal or vertical. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>- starting point of the new road. </td></tr>
    <tr><td class="paramname">end</td><td>- ending point of the new road. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a20b57828696dfc9e8a2f3384d5d29bae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PtrCross CrossFactory::findCrossByPoint </td>
          <td>(</td>
          <td class="paramtype">const PtrToConstPoint &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the cross that has the same position as the given point as the argument. </p>
<p>Return cross that has the same position as given. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>- given point to search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cross that has the same point as given. </dd></dl>

</div>
</div>
<a class="anchor" id="ae1ea5359b31f09f76510c90e9b4552e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CrossFactory::horizCrossedRoad </td>
          <td>(</td>
          <td class="paramtype">const PtrToConstPoint &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PtrToConstPoint &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates crosses if new road crosses the existed one horizontaly. </p>
<p>This method creates new crosses if the new road crosses with the another roads. The new road is horizontal. At first, crosses are sorted. The first is cross that has the smallest x value of the position. Then we check each pair of cross and it's south neighbour, if the new road doesn't cross the road between these pair of crosses. If it crosses, new crosses are added and neighbours are updated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>- point on the west of the new road. </td></tr>
    <tr><td class="paramname">end</td><td>- point on the east of the new road. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aabc61b3a89fc71f7758780135c599e97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CrossFactory::twoHorizRoads </td>
          <td>(</td>
          <td class="paramtype">const PtrToConstPoint &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PtrToConstPoint &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates crosses if new road hide the existing, both roads are horizontaly. </p>
<p>Check if two roads are horizontal and both of roads have the same y value. (If one road hides another road). At first crosses are sorted. First cross should has the smallest y value of the position. Then we look for the two crosses, between which the new road is being tried to set. If found, we create new crosses and update neighbours from the west to the east. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>- point on the west of the new road. </td></tr>
    <tr><td class="paramname">end</td><td>- point on the east of the new road. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac699978962ee263fb01c189891cb4a9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CrossFactory::twoVertRoads </td>
          <td>(</td>
          <td class="paramtype">const PtrToConstPoint &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PtrToConstPoint &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates crosses if new road hide the existing, both roads are verticaly. </p>
<p>Check if two roads are vertical and both of roads have the same x value. (If one road hides another road). At first crosses are sorted. First cross should has the smallest x value of the position Then we look for the two crosses, between which the new road is being tried to set. If found, we create new crosses and update neighbours from the north to the south. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>- point on the north of the new road. </td></tr>
    <tr><td class="paramname">end</td><td>- point on the south of the new road. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae8ac0c74d33e41161119e56e9995243e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CrossFactory::vertCrossedRoad </td>
          <td>(</td>
          <td class="paramtype">const PtrToConstPoint &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PtrToConstPoint &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates crosses if new road crosses the existed one verticaly. </p>
<p>This method creates new crosses if the new road crosses with the another roads. The new road is vertical. At first, crosses are sorted. The first is cross that has the smallest y value of the position. Then we check each pair of cross and it's east neighbour, if the new road doesn't cross the road between these pair of crosses. If it crosses, new crosses are added and neighbours are updated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>- point on the north of the new road. </td></tr>
    <tr><td class="paramname">end</td><td>- point on the south of the new road. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/aleksander/CLionProjects/Zpr/src/<a class="el" href="CrossFactory_8h_source.html">CrossFactory.h</a></li>
<li>/home/aleksander/CLionProjects/Zpr/src/<a class="el" href="CrossFactory_8cpp.html">CrossFactory.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
